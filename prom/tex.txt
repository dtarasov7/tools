Метрики Prometheus / Формат OpenMetrics
Текстовый формат метрик Prometheus ориентирован на строки. 
Строки разделяются символом перевода строки (\n). 
Последняя строка должна заканчиваться символом перевода строки. 
Пустые строки игнорируются.


Метрика состоит из нескольких полей:

- Название метрики
- Любое количество меток (может быть 0), представленных в виде массива ключ-значение
- Текущее значение метрики
- Необязательная метка времени метрики

Метрика Prometheus может быть такой простой, как:

http_requests 2

Или, включая все указанные компоненты:

http_requests_total{method="post",code="400"}  3   1395066363000

Выходным данным метрик обычно предшествуют 
# HELP строки 
# TYPE метаданных

Строка HELP определяет имя метрики и ее краткое описание. 
Строка TYPE определяет тип метрики. 
Если перед метрикой нет TYPE, метрика устанавливается как нетипизированная. 
Все остальное, что начинается с #, анализируется как комментарий.

# HELP metric_name Description of the metric
# TYPE metric_name type
# Comment that's not parsed by prometheus


# HELP http_requests_total Total http requests
# TYPE http_requests_total counter
http_requests_total{method="post",code="400"}  3   1395066363000

counter
Это кумулятивная метрика, которая со временем только увеличивается, например, количество запросов к конечной точке.

Примечание: вместо использования счетчика для измерения уменьшающихся значений используйте gauge.

# HELP go_memstats_alloc_bytes_total Total number of bytes allocated, even if freed.
# TYPE go_memstats_alloc_bytes_total counter
go_memstats_alloc_bytes_total 3.7156890216e+10

gauge
gauge — это мгновенные измерения значения. Они могут быть произвольными значениями, которые будут записаны.

gauge отображают случайное значение, которое может произвольно увеличиваться и уменьшаться, например, нагрузку вашей системы.

# HELP go_goroutines Number of goroutines that currently exist.
# TYPE go_goroutines gauge
go_goroutines 73

histogram
Гистограмма выбирает наблюдения (обычно такие вещи, как длительность запросов или размеры ответов) и подсчитывает их в настраиваемых сегментах. Она также предоставляет сумму всех наблюдаемых значений.
Гистограмма с именем базовой метрики отображает несколько временных рядов во время сбора данных:

# HELP http_request_duration_seconds request duration histogram
# TYPE http_request_duration_seconds histogram
http_request_duration_seconds_bucket{le="0.5"} 0
http_request_duration_seconds_bucket{le="1"} 1
http_request_duration_seconds_bucket{le="2"} 2
http_request_duration_seconds_bucket{le="3"} 3
http_request_duration_seconds_bucket{le="5"} 3
http_request_duration_seconds_bucket{le="+Inf"} 3
http_request_duration_seconds_sum 6
http_request_duration_seconds_count 3


summary

Подобно гистограмме, сводка выборок наблюдений (обычно это такие вещи, как длительность запросов и размеры ответов). 
Хотя она также предоставляет общее количество наблюдений и сумму всех наблюдаемых значений, 
она вычисляет настраиваемые квантили в скользящем временном окне.

summary с базовым именем метрики также раскрывает несколько временных рядов во время сбора данных:

# HELP go_gc_duration_seconds A summary of the GC invocation durations.
# TYPE go_gc_duration_seconds summary
go_gc_duration_seconds{quantile="0"} 3.291e-05
go_gc_duration_seconds{quantile="0.25"} 4.3849e-05
go_gc_duration_seconds{quantile="0.5"} 6.2452e-05
go_gc_duration_seconds{quantile="0.75"} 9.8154e-05
go_gc_duration_seconds{quantile="1"} 0.011689149
go_gc_duration_seconds_sum 3.451780079
go_gc_duration_seconds_count 13118

https://github.com/prometheus-net/prometheus-net

https://github.com/prometheus-net/grafana-dashboards


Названия метрик

Use lower-case letters (a-z), digits (0-9) and underscores (_) in the string

В Prometheus есть несколько специальных суффиксов для временных рядов:  

_total, _count, _sum и _bucket. Из них вы всегда должны использовать _total с Counters, 
и в противном случае избегайте использования этих суффиксов в ваших метриках. 

Gauge, заканчивающийся на _countor, _total довольно запутан, так как подразумевает, 
что это Counter, а не Gauge.

...должны соответствовать модели данных для допустимых символов.
...должен иметь префикс приложения (из одного слова), относящийся к домену, 
к которому принадлежит метрика. Префикс иногда упоминается namespaceклиентскими библиотеками как. 
Для метрик, специфичных для приложения, префиксом обычно является само имя приложения. 
Однако иногда метрики более общие, например стандартизированные метрики, экспортируемые клиентскими библиотеками. 

Примеры:
prometheus_notifications_total (специфично для сервера Prometheus)
process_cpu_seconds_total (экспортируется многими клиентскими библиотеками)
http_request_duration_seconds (для всех HTTP-запросов)

...должны иметь единую единицу измерения (т.е. не путать секунды с миллисекундами или секунды с байтами).
...следует использовать базовые единицы (например, секунды, байты, метры, а не миллисекунды, мегабайты, километры). 
Ниже приведен список базовых единиц.
...должен иметь суффикс, описывающий единицу, во множественном числе. 
Обратите внимание, что накапливающийся счет имеет total в качестве суффикса, в дополнение к единице, если применимо.

http_request_duration_seconds
node_memory_usage_bytes
http_requests_total (для безразмерного накапливаемого счета)
process_cpu_seconds_total (для накапливающегося счета с единицей)
foobar_build_info (для псевдометрики, которая предоставляет метаданные о запущенном двоичном файле)
data_pipeline_last_record_processed_timestamp_seconds (для временной метки, 
которая отслеживает время последней записи, обработанной в конвейере обработки данных)

...должны представлять одну и ту же логическую измеряемую вещь по всем параметрам этикетки.
длительность запроса
байты передачи данных
мгновенное использование ресурсов в процентах

Как правило, либо то, sum()либо avg()все измерения данной метрики должны быть значимыми 
(хотя и не обязательно полезными). Если это не имеет смысла, разделите данные на несколько метрик. 

Например, иметь емкость различных очередей в одной метрике хорошо, 
а смешивать емкость очереди с текущим числом элементов в очереди — нет.

Не помещайте названия меток в название метрики, например  http_server_requests_by_method_total. 
Когда метка агрегируется, это вызовет путаницу. 
Есть один очень редкий случай, когда это допустимо, 
и это когда вам нужно различать несколько метрик, основанных на одних и тех же событиях, 
но имеющих разные метки из соображений производительности


Аналогично не указывайте тип метрики в названии, например gauge, counter, summary или map. 
Это уже подразумевается существующей схемой именования, не добавляет никакой информации и 
вызовет путаницу при обработке и написании правил на основе метрик. Например, не имеет значения, 
рассчитали ли вы частоту запросов из Counter или Summary

Prometheus предпочитает snake_case (node_package_manager), избегайте CamelCase (nodePackageManager) при создании собственных метрик

Если у вас есть количество успешных запросов и количество неудачных запросов, 
лучший способ представить это как одну метрику для общего количества запросов и другую метрику для неудачных запросов. 
Это упрощает расчет коэффициента отказов. Не используйте одну метрику с меткой «неудачный» или «успех». 
Аналогично, с попаданием или промахом для кэшей лучше иметь одну метрику для общего количества и другую для попаданий.

Префиксы process_и scrape_зарезервированы. 
Можно добавлять к ним свой собственный префикс, если они соответствуют семантике соответствия. 
Например, у Prometheus есть метрика, которая показывает, scrape_duration_secondsсколько времени 
заняло считывание, и хорошей практикой будет также иметь ориентированную на экспортера метрику, 
например jmx_scrape_duration_seconds, указывающую, сколько времени потребовалось конкретному 
экспортеру для выполнения своей задачи.

метрика с версией - позволит построить дашборд  на котором видно какие сейчас работают версии того или иного сервиса
dbokb_service{version="v1.0.3",service_name="xyz"} 1

А так как prometheus добавит метку instance , то можно будет показывать и кол-во экземпляров

Например, сам Prometheus экспортирует временной ряд с именем prometheus_build_info:
prometheus_build_info{branch="HEAD",goversion="go1.6.2", revision="16d70a8b6bd90f0ff793813405e84d5724a9ba65",version="1.0.1"} 1


Метки
Use lower-case letters (a-z), digits (0-9) and underscores (_) in the string
Используйте метки, чтобы различать характеристики измеряемой вещи:

api_http_requests_total- различать типы запросов:operation="create|update|delete"
api_request_duration_seconds- различать этапы запроса:stage="extract|transform|load"
Не включайте названия меток в название метрики, так как это приведет к избыточности и возникновению путаницы, 
если соответствующие метки будут объединены.

ВНИМАНИЕ: Помните, что каждая уникальная комбинация пар «ключ-значение» представляет собой новый временной ряд,
 что может значительно увеличить объем хранимых данных. 
Не используйте метки для хранения измерений с высокой кардинальностью (множество различных значений меток), 
таких как идентификаторы пользователей, адреса электронной почты или другие неограниченные наборы значений.

Избегайте type в качестве имени метки, это слишком общее и часто бессмысленное. 
Вы также должны стараться, где это возможно, избегать имен, которые могут конфликтовать 
с целевыми метками, такими как region, zone, cluster, availability_zone, az, datacenter, 
dc, owner, customer, stage, service, environmentи env. 
Если, однако, это то, как приложение называет какой-либо ресурс, лучше не вызывать путаницу, переименовывая его

Метка leимеет особое значение для гистограмм и quantileдля сводок. Избегайте этих меток вообще


