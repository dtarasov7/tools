https://valyala.medium.com/promql-tutorial-for-beginners-9ab455142085

Учебник PromQL для новичков и людей
Александр Валялкин
Александр Валялкин

·
Следовать

8 мин чтения
·
24 марта 2019 г.
1,3 тыс.


7



Photo by Markus Spiske on Unsplash
PromQL — это язык запросов для системы мониторинга Prometheus . Он предназначен для создания мощных, но простых запросов для графиков, оповещений или производных временных рядов (т. н. правил записи ). PromQL разработан с нуля и не имеет никаких общих оснований с другими языками запросов, используемыми в базах данных временных рядов, такими как SQL в TimescaleDB , InfluxQL или Flux .

Это позволило создать понятный язык для типичных запросов TSDB. Но это имеет свою цену — новичкам обычно нужно потратить несколько часов на чтение официальной документации PromQL, прежде чем они поймут, как это работает. Давайте выровняем и сократим кривую обучения PromQL.

Выбор временного ряда с помощью PromQL
Выбор временного ряда с помощью PromQL так же прост, как написание имени временного ряда в запросе. Например, следующий запрос вернет все временные ряды с именем node_network_receive_bytes_total:

узел_сети_получить_байты_всего
Это имя соответствует метрике node_exporter , содержащей количество байтов, полученных через различные сетевые интерфейсы. Такой простой запрос может возвращать несколько временных рядов с заданным именем, но с различным набором меток. Например, запрос выше может возвращать временные ряды со следующими метками для eth0и eth1сетевых eth2интерфейсов:

node_network_receive_bytes_total{устройство="eth0"} 
node_network_receive_bytes_total{устройство="eth1"} 
node_network_receive_bytes_total{устройство="eth2"}
Отдельные метки заключаются в фигурные скобки: {device="eth0"}, {device="eth1"}, {device="eth2"}.

Давайте рассмотрим тот же запрос в SQL-коде TimescaleDB:

SELECT 
  ts.metric_name_plus_tags, 
  r.timestamps, 
  r.values 
​​FROM ( 
  (SELECT 
    time_series_id, 
    array_agg(timestamp ORDER BY timestamp) AS timestamps, 
    array_agg(value ORDER BY timestamp) AS values 
  ​​FROM 
    metrics 
  WHERE 
    time_series_id IN ( 
      SELECT id FROM time_series 
      WHERE metric_name = 'node_network_receive_bytes_total' 
    ) 
  GROUP BY 
    time_series_id 
  ) 
) AS r JOIN time_series AS ts ON (r.time_series_id = ts.id)
Легко, не правда ли? :) SQL должен быть еще сложнее, чтобы соответствовать однословному запросу PromQL выше, поскольку он не учитывает временные диапазоны и понижение частоты дискретизации, которые автоматически обрабатываются API /query_range для PromQL с аргументами start, endи step.

Фильтрация по метке
Одно имя метрики может соответствовать нескольким временным рядам с различными наборами меток, как в примере выше. Как выбрать только соответствие временным рядам {device="eth1"}? Просто укажите требуемую метку в запросе:

node_network_receive_bytes_total{устройство="eth1"}
Если вы хотите выбрать все временные ряды для устройств, отличных от eth1, то просто замените =на !=в запросе:

node_network_receive_bytes_total{устройство!="eth1"}
Как выбрать временные ряды для устройств, начинающихся с eth? Просто используйте регулярные выражения:

node_network_receive_bytes_total{устройство=~"eth.+"}
Фильтр может содержать произвольные регулярные выражения, совместимые с Go (также известные как RE2).

Для выбора всех временных рядов для устройств, не начинающихся с eth, =~необходимо заменить на !~:

node_network_receive_bytes_total{устройство!~"eth.+"}
Фильтрация по нескольким меткам
Фильтры меток могут быть объединены. Например, следующий запрос вернет только временные ряды для экземпляра node42:9100для устройств, начинающихся с eth:

node_network_receive_bytes_total{instance="node42:9100", device=~"eth.+"}
Фильтры меток объединяются с andоператором между ними, то есть «возврат временного ряда, соответствующего этому фильтру and». Как реализовать orоператор? В настоящее время в PromQL отсутствует orоператор для объединения фильтров меток, но в большинстве случаев его можно заменить регулярным выражением. Например, следующий запрос вернет временной ряд для eth1или loустройств:

node_network_receive_bytes_total{устройство=~"eth1|lo"}
Примечание: MetricsQL — PromQL-совместимый язык запросов от VictoriaMetrics — поддерживает orоператор внутри фигурных скобок. Например, следующий запрос выбирает node_tework_receive_bytes_totalметрику из device="eth1"или из instance="node42:9100:

node_network_receive_bytes_total{устройство="eth1" или экземпляр="node42:9100"}
Более подробную информацию смотрите в этих документах .

Фильтрация по регулярным выражениям по названию метрики
Иногда требуется возврат всех временных рядов для нескольких имен метрик. Имя метрики — это просто обычная метка со специальным именем — __name__. Поэтому фильтрация по нескольким именам метрик может быть выполнена путем применения регулярных выражений к именам метрик. Например, следующий запрос возвращает все временные ряды с именами метрик node_network_receive_bytes_totalили node_network_transmit_bytes_total:

{__name__=~"node_network_(прием|передача)_байт_всего"}
Сравнение текущих данных с историческими данными
PromQL позволяет запрашивать исторические данные и объединять/сравнивать их с текущими данными. Просто добавьте offsetк запросу. Например, следующий запрос вернет недельные данные для всех временных рядов с node_network_receive_bytes_totalименем:

node_network_receive_bytes_total смещение 7d
Следующий запрос вернет точки, в которых текущие накладные расходы на сборку мусора превышают часовые накладные расходы на сборку мусора в 1,5 раза.

go_memstats_gc_cpu_fraction > 1,5 * (смещение go_memstats_gc_cpu_fraction 1 час)
Операции >и *поясняются ниже.

Расчет ставок
Внимательные читатели могли заметить, что Grafana рисует постоянно растущие линии для всех приведенных выше запросов:


График для постоянно растущего счетчика
Удобство использования таких графиков близко к нулю, поскольку они показывают трудно интерпретируемые постоянно растущие значения счетчиков, в то время как нам нужны графики пропускной способности сети — см. МБ/с слева от графика. В PromQL есть волшебная функция для этого — rate() . Она вычисляет посекундную скорость для всех соответствующих временных рядов:

скорость(node_network_receive_bytes_total[5m])
Теперь график становится правильным:


График для скорости (счетчик[5м])
Что [5m]означает в запросе? Это временная продолжительность ( d) — в нашем случае 5 минут — для просмотра при расчете посекундной ставки для каждой точки на графике. Упрощенный расчет ставки для каждой точки выглядит как (Vcurr-Vprev)/(Tcurr-Tprev), где Vcurr— значение в текущей точке — Tcurr, Vprev— значение в точке Tprev=Tcurr-d.

Если это выглядит слишком сложным, то просто запомните — чем выше значение d, тем сглаживается график, а чем ниже — dтем больше шума на нем. Также есть расширение PromQL , поддерживаемое VictoriaMetrics , где [d]может быть опущено — в этом случае оно равно длительности между двумя последовательными точками на графике (он же step):

скорость(node_network_receive_bytes_total)
Ошибки с ставкой
Скорость удаляет название метрики, оставляя все метки для внутреннего временного ряда.

Не применяется rateк временным рядам, которые могут увеличиваться и уменьшаться. Такие временные ряды называются Gauges . Rateдолжны применяться только к Counters , которые всегда увеличиваются, но иногда могут быть сброшены до нуля (например, при перезапуске службы).

Не используйте irateвместо rate, так как он не улавливает пики и не намного быстрее rate.

Арифметические операции
PromQL поддерживает все основные арифметические операции :

дополнение (+)
вычитание (-)
умножение (*)
разделение (/)
модуль (%)
мощность (^)
Это позволяет выполнять различные преобразования. Например, преобразование байт/с в бит/с:

скорость(node_network_receive_bytes_total[5m]) * 8
Кроме того, это позволяет выполнять вычисления кросс-временных рядов. Например, чудовищный запрос Flux из этой статьи можно упростить до следующего запроса PromQL:

co2 * (((temp_c + 273,15) * 1013,25) / (давление * 298,15))
Объединение нескольких временных рядов с арифметическими операциями требует понимания правил сопоставления . В противном случае запрос может сломаться или привести к неверным результатам. Основы правил сопоставления просты:

Движок PromQL удаляет названия метрик из всех временных рядов слева и справа от арифметической операции, не трогая метки.
Для каждого временного ряда слева движок PromQL ищет соответствующий временной ряд справа с тем же набором меток, применяет операцию для каждой точки данных и возвращает полученный временной ряд с тем же набором меток. Если совпадений нет, то временной ряд удаляется из результата.
Правила сопоставления могут быть дополнены модификаторами ignoring, on, group_leftи . Это действительно сложно, но в большинстве случаев это не нужно.group_right

Операции сравнения
PromQL поддерживает следующие операторы сравнения :

равно (==)
не равно (!=)
больше (>)
больше или равно (>=)
меньше (<)
меньше или равно (<=)
Эти операторы могут применяться к произвольным выражениям PromQL, как и к арифметическим операторам. Результатом операции сравнения является временной ряд с единственными совпадающими точками данных. Например, следующий запрос вернет только пропускную способность менее 2300 байт/с:

скорость(node_network_receive_bytes_total[5m]) < 2300
Это приведет к следующему графику с пробелами, где пропускная способность превышает 2300 байт/с:


скорость(node_network_receive_bytes_total[5m]) < 2300
Результат оператора сравнения может быть дополнен boolмодификатором:

скорость(node_network_receive_bytes_total[5m]) < bool 2300
В этом случае результат будет содержать 1 для истинных сравнений и 0 для ложных сравнений:


скорость(node_network_receive_bytes_total[5m]) < bool 2300
Функции агрегации и группировки
PromQL позволяет агрегировать и группировать временные ряды . Временные ряды группируются по заданному набору меток, а затем заданная функция агрегации применяется к каждой группе. Например, следующий запрос вернет суммарный входящий трафик по всем сетевым интерфейсам, сгруппированный по экземплярам (узлам с установленными node_exporter):

сумма(скорость(node_network_receive_bytes_total[5m])) по (экземпляр)
Работа с датчиками
Датчики — это временные ряды, которые могут увеличиваться и уменьшаться в любое время. Например, использование памяти, температура или давление. При построении графиков для датчиков ожидается, что будут отображаться минимальные, максимальные, средние и/или квантильные значения для каждой точки на графике. PromQL позволяет делать это с помощью следующих функций :

мин_сверх_времени
max_over_time
avg_over_time
квантиль_по_времени
Например, следующий запрос построит график минимального значения свободной памяти для каждой точки на графике:

min_over_time(node_memory_MemFree_bytes[5m])
VictoriaMetrics добавляет rollup_*функции в PromQL, которые автоматически возвращают min, maxи avgзначение при применении к Gagues. Например:

свертка(node_memory_MemFree_bytes)
Манипуляции с ярлыками
PromQL предоставляет две функции для изменения, улучшения, удаления или создания меток:

метка_заменить
label_join
Хотя эти функции неудобны в использовании, они позволяют выполнять мощные динамические манипуляции для меток в выбранном временном ряду. Основной вариант использования label_функций — преобразование меток в желаемый вид.

VictoriaMetrics расширяет эти функции более удобными функциями манипулирования метками :

label_set— устанавливает дополнительные метки для временных рядов
label_del— удаляет заданные метки из временного ряда
label_keep— удаляет все метки из временного ряда, кроме указанных меток
label_copy— копирует значения меток в другие метки
label_move — переименовывает метки
label_transform— заменяет все подстроки, соответствующие заданному регулярному выражению, на шаблонную замену
label_value— возвращает числовое значение из указанной метки
Возврат нескольких результатов из одного запроса
Иногда необходимо вернуть несколько результатов из одного запроса PromQL. Это можно сделать с помощью orоператора . Например, следующий запрос вернет все временные ряды с именами metric1, metric2и metric3:

метрика1 или метрика2 или метрика3
VictoriaMetrics упрощает возврат нескольких результатов — просто перечислите их внутри ():

(метрика1, метрика2, метрика3)
Обратите внимание, что вместо имен метрик можно использовать произвольные выражения PromQL.

При объединении результатов выражений есть распространенная ловушка: результаты с дублирующим набором меток пропускаются. Например, следующий запрос пропустит sum(b), так как оба sum(a)и sum(b)имеют идентичный набор меток — у них вообще нет меток:

сумма(а) или сумма(б)
Выводы
PromQL — простой, но мощный язык запросов для баз данных временных рядов. Он позволяет писать типичные запросы TSDB лаконично, но понятно, особенно по сравнению с SQL, InfluxQL или Flux. Он может не охватывать специфические случаи, которые поддерживаются мощными запросами SQL. Но эти случаи настолько редки на практике, что я не смог вспомнить хотя бы один на данный момент. Упомяните такие случаи в комментариях, если вы о них знаете.

В руководстве не рассматриваются все функциональные возможности PromQL, поскольку новички редко используют его:

В нем не упоминается множество функций и логических операторов .
Он не распространяется на подзапросы .
Он не охватывает общие табличные выражения из MetricsQL (также известные CTEкак WITH templates ), которые позволяют упростить сложные запросы PromQL с множеством повторяющихся фильтров меток, шаблонизированных в Grafana.
В нем не рассматриваются другие полезные функции MetricsQL, поддерживаемые VictoriaMetrics .
Я бы рекомендовал продолжить изучение PromQL с помощью этой шпаргалки .

Обновление №1: VictoriaMetrics теперь с открытым исходным кодом ! Изучите исходный код, чтобы понять, как он реализует MetricsQL. Присоединяйтесь к нашему чату Slack .

Обновление №2: ознакомьтесь со статьей, в которой объясняются технические термины, связанные с Prometheus .

Обновление №2: узнайте, как оптимизировать запросы PromQL в Prometheus .
